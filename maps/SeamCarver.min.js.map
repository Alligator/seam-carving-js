{"version":3,"sources":["SeamCarver.min.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","RED","GREEN","BLUE","BORDER_ENERGY","SeamCarver","canvas","this","width","height","context","getContext","imageData","getImageData","picture","data","energyMatrix","Array","minsumMatrix","minxMatrix","Float32Array","Uint16Array","console","time","createEnergyMatrix","timeEnd","value","x","y","index","parseInt","red","green","blue","rgb","num","isBorderPixel","pos_xant","pixelToIndex","pos_xpost","pos_yant","pos_ypost","p","score","Math","sqrt","energy_cell","energy","vminsum","Number","POSITIVE_INFINITY","minx","cursum","maxVminsum","recalculate","max","vseam","xminsum","createImageData","row","deletedCol","col","oldPos","pos","pos_right","energy_right","minx_right","minsum_right","splice","queue","affectedCols","pixelInRange","push","marked","enqueued","enqueuedCols","lastCol","pop","pixelIndex","nodeEnergy","oldVminsum","min","parentVminsum","newVminsum","childIndex","removePixelsFromDataStructures","affectedPixels","recalculateEnergiesAndFindAffectedPixels","recalculateVminsumForAffectedPixels","options","field","actualSize","clearRect","style","dataField","val","normalizedVal","direction","putImageData","log","toString","lines","slice","rgbToNum","toFixed"],"mappings":"CAAA,QAAUA,GAAEC,EAAEC,EAAEC,GAAG,QAASC,GAAEC,EAAEC,GAAG,IAAIJ,EAAEG,GAAG,CAAC,IAAIJ,EAAEI,GAAG,CAAC,GAAIE,GAAkB,kBAATC,UAAqBA,OAAQ,KAAIF,GAAGC,EAAE,MAAOA,GAAEF,GAAE,EAAI,IAAGI,EAAE,MAAOA,GAAEJ,GAAE,EAAI,IAAIK,GAAE,GAAIC,OAAM,uBAAuBN,EAAE,IAAK,MAAMK,GAAEE,KAAK,mBAAmBF,EAAE,GAAIG,GAAEX,EAAEG,IAAIS,WAAYb,GAAEI,GAAG,GAAGU,KAAKF,EAAEC,QAAQ,SAASd,GAAG,GAAIE,GAAED,EAAEI,GAAG,GAAGL,EAAG,OAAOI,GAAEF,EAAEA,EAAEF,IAAIa,EAAEA,EAAEC,QAAQd,EAAEC,EAAEC,EAAEC,GAAG,MAAOD,GAAEG,GAAGS,QAAkD,IAAI,GAA1CL,GAAkB,kBAATD,UAAqBA,QAAgBH,EAAE,EAAEA,EAAEF,EAAEa,OAAOX,IAAID,EAAED,EAAEE,GAAI,OAAOD,KAAKa,GAAG,SAAST,EAAQU,EAAOJ,GACvd,YAIA,SAASK,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAFhH,GAAIC,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIjB,GAAI,EAAGA,EAAIiB,EAAMV,OAAQP,IAAK,CAAE,GAAIkB,GAAaD,EAAMjB,EAAIkB,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeP,EAAQE,EAAWM,IAAKN,IAAiB,MAAO,UAAUN,EAAaa,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBH,EAAYe,UAAWF,GAAiBC,GAAaX,EAAiBH,EAAac,GAAqBd,MAI5hBgB,EAAM,EACNC,EAAQ,EACRC,EAAO,EACPC,EAAgB,IAIhBC,EAAa,WASb,QAASA,GAAWC,GAChBvB,EAAgBwB,KAAMF,GAEtBE,KAAKD,OAASA,EACdC,KAAKC,MAAQF,EAAOE,MACpBD,KAAKE,OAASH,EAAOG,OACrBF,KAAKG,QAAUJ,EAAOK,WAAW,MACjCJ,KAAKK,UAAYL,KAAKG,QAAQG,aAAa,EAAG,EAAGN,KAAKC,MAAOD,KAAKE,QAClEF,KAAKO,QAAUP,KAAKK,UAAUG,KAK9BR,KAAKS,aAAe,GAAIC,OAAMV,KAAKC,OACnCD,KAAKW,aAAe,GAAID,OAAMV,KAAKC,OACnCD,KAAKY,WAAa,GAAIF,OAAMV,KAAKC,MACjC,KAAK,GAAInC,GAAI,EAAGA,EAAIkC,KAAKC,MAAOnC,IAC5BkC,KAAKS,aAAa3C,GAAK,GAAI+C,cAAab,KAAKE,QAC7CF,KAAKW,aAAa7C,GAAK,GAAI+C,cAAab,KAAKE,QAC7CF,KAAKY,WAAW9C,GAAK,GAAIgD,aAAYd,KAAKE,OAG9Ca,SAAQC,KAAK,sBAEbhB,KAAKiB,qBAELF,QAAQG,QAAQ,sBAoepB,MAvdAtC,GAAakB,IACTR,IAAK,eACL6B,MAAO,SAAsBC,EAAGC,GAC5B,GAAID,EAAI,GAAKA,GAAkB,EAAbpB,KAAKC,OAAaoB,EAAI,GAAKA,GAAKrB,KAAKE,OACnD,KAAM,IAAIlC,OAAM,+BAAiCoD,EAAI,IAAMC,EAG/D,OAA8B,IAAtBA,EAAIrB,KAAKC,MAAQmB,MAG7B9B,IAAK,WACL6B,MAAO,SAAkBG,GACrB,MAAOC,UAASD,EAAQ,EAAItB,KAAKC,UAGrCX,IAAK,WACL6B,MAAO,SAAkBG,GACrB,MAAOC,UAASD,GAAsB,EAAbtB,KAAKC,WAGlCX,IAAK,WACL6B,MAAO,SAAkBK,EAAKC,EAAOC,GACjC,GAAIC,GAAMH,CAGV,OAFAG,IAAOA,GAAO,GAAKF,EACnBE,GAAOA,GAAO,GAAKD,KAIvBpC,IAAK,WACL6B,MAAO,SAAkBS,GACrB,GAAIJ,GAAMI,GAAO,GAAK,IAClBH,EAAQG,GAAO,EAAI,IACnBF,EAAa,IAANE,CACX,QAAQJ,EAAKC,EAAOC,MAGxBpC,IAAK,gBACL6B,MAAO,SAAuBC,EAAGC,GAC7B,MAAOD,IAAK,GAAKC,GAAK,GAAKD,GAAKpB,KAAKC,MAAQ,GAAKoB,GAAKrB,KAAKE,OAAS,KAGzEZ,IAAK,eACL6B,MAAO,SAAsBC,EAAGC,GAC5B,MAAOD,IAAK,GAAKC,GAAK,GAAKD,GAAKpB,KAAKC,MAAQ,GAAKoB,GAAKrB,KAAKE,OAAS,KAYzEZ,IAAK,SACL6B,MAAO,SAAgBC,EAAGC,GACtB,GAAIrB,KAAK6B,cAAcT,EAAGC,GACtB,MAAOxB,EAGX,IAAIiC,GAAW9B,KAAK+B,aAAaX,EAAI,EAAGC,GACpCW,EAAYhC,KAAK+B,aAAaX,EAAI,EAAGC,GACrCY,EAAWjC,KAAK+B,aAAaX,EAAGC,EAAI,GACpCa,EAAYlC,KAAK+B,aAAaX,EAAGC,EAAI,GAErCc,EAAInC,KAAKO,QAGT6B,EAAQC,KAAKC,MAAMH,EAAEH,EAAYtC,GAAOyC,EAAEL,EAAWpC,KAASyC,EAAEH,EAAYtC,GAAOyC,EAAEL,EAAWpC,KAASyC,EAAEH,EAAYrC,GAASwC,EAAEL,EAAWnC,KAAWwC,EAAEH,EAAYrC,GAASwC,EAAEL,EAAWnC,KAAWwC,EAAEH,EAAYpC,GAAQuC,EAAEL,EAAWlC,KAAUuC,EAAEH,EAAYpC,GAAQuC,EAAEL,EAAWlC,KAAUuC,EAAED,EAAYxC,GAAOyC,EAAEF,EAAWvC,KAASyC,EAAED,EAAYxC,GAAOyC,EAAEF,EAAWvC,KAASyC,EAAED,EAAYvC,GAASwC,EAAEF,EAAWtC,KAAWwC,EAAED,EAAYvC,GAASwC,EAAEF,EAAWtC,KAAWwC,EAAED,EAAYtC,GAAQuC,EAAEF,EAAWrC,KAAUuC,EAAED,EAAYtC,GAAQuC,EAAEF,EAAWrC,IACziB,OAAOwC,MASX9C,IAAK,cACL6B,MAAO,SAAqBC,EAAGC,GAC3B,GAAIkB,KAMJ,IAJAA,EAAYC,OAASxC,KAAKwC,OAAOpB,EAAGC,GACpCkB,EAAYE,QAAUC,OAAOC,kBAGzBtB,GAAKrB,KAAKE,OAAS,EACnBqC,EAAYE,QAAUF,EAAYC,OAClCD,EAAYK,KAAOxB,MAChB,CACH,GAAIyB,GAAS,CAITzB,GAAI,GAAK,IACTmB,EAAYE,QAAUzC,KAAKW,aAAaS,EAAI,GAAGC,EAAI,GAAKkB,EAAYC,OACpED,EAAYK,KAAOxB,EAAI,GAIvBA,EAAIpB,KAAKC,QACT4C,EAAS7C,KAAKW,aAAaS,GAAGC,EAAI,GAAKkB,EAAYC,OAC/CK,EAASN,EAAYE,UACrBF,EAAYE,QAAUI,EACtBN,EAAYK,KAAOxB,IAKvBA,EAAI,EAAIpB,KAAKC,QACb4C,EAAS7C,KAAKW,aAAaS,EAAI,GAAGC,EAAI,GAAKkB,EAAYC,OACnDK,EAASN,EAAYE,UACrBF,EAAYE,QAAUI,EACtBN,EAAYK,KAAOxB,EAAI,IAKnC,MAAOmB,MAkBXjD,IAAK,qBACL6B,MAAO,WAEHnB,KAAK8C,WAAa,CAClB,KAAK,GAAIzB,GAAIrB,KAAKE,OAAS,EAAGmB,GAAK,EAAGA,IAElC,IAAK,GAAID,GAAI,EAAGA,EAAIpB,KAAKC,MAAOmB,IAAK,CACjC,GAAIoB,GAASxC,KAAK+C,YAAY3B,EAAGC,EACjCrB,MAAK8C,WAAaT,KAAKW,IAAIR,EAAOC,QAASzC,KAAK8C,YAChD9C,KAAKS,aAAaW,GAAGC,GAAKmB,EAAOA,OACjCxC,KAAKW,aAAaS,GAAGC,GAAKmB,EAAOC,QACjCzC,KAAKY,WAAWQ,GAAGC,GAAKmB,EAAOI,SAW3CtD,IAAK,mBACL6B,MAAO,WAOH,IAAK,GAND8B,MAEAC,EAAU,EACVT,EAAUC,OAAOC,kBAGZvB,EAAI,EAAGA,EAAIpB,KAAKC,MAAOmB,IACxBpB,KAAKW,aAAaS,GAAG,GAAKqB,IAC1BA,EAAUzC,KAAKW,aAAaS,GAAG,GAC/B8B,EAAU9B,EAIlB6B,GAAM,GAAKC,CAIX,KADA,GAAI7B,GAAI,EACDA,EAAIrB,KAAKE,OAAS,GACrBgD,EAAUlD,KAAKY,WAAWsC,GAAS7B,GACnCA,IACA4B,EAAM5B,GAAK6B,CAGf,OAAOD,MAUX3D,IAAK,iCACL6B,MAAO,SAAwC8B,GAC3CjD,KAAKK,UAAYL,KAAKG,QAAQgD,gBAAgBnD,KAAKC,MAAQ,EAAGD,KAAKE,OACnE,KAAK,GAAIkD,GAAMpD,KAAKE,OAAS,EAAGkD,GAAO,EAAGA,IAAO,CAI7C,IAAK,GAHDC,GAAaJ,EAAMG,GAGdE,EAAM,EAAGA,EAAMD,EAAYC,IAGhC,IAAK,GAFDC,GAASvD,KAAK+B,aAAauB,EAAKF,GAChCI,EAAMD,EAAe,EAANH,EACVtF,EAAI,EAAGA,EAAI,EAAGA,IACnBkC,KAAKK,UAAUG,KAAKgD,EAAM1F,GAAKkC,KAAKO,QAAQgD,EAASzF,EAM7D,KAAK,GAAIwF,GAAMD,EAAYC,EAAMtD,KAAKC,MAAQ,EAAGqD,IAAO,CAKpD,IAAK,GAFDE,GAAMxD,KAAK+B,aAAauB,EAAKF,GAAa,EAANA,EACpCK,EAAYzD,KAAK+B,aAAauB,EAAM,EAAGF,GAClCtF,EAAI,EAAGA,EAAI,EAAGA,IACnBkC,KAAKK,UAAUG,KAAKgD,EAAM1F,GAAKkC,KAAKO,QAAQkD,EAAY3F,EAI5D,IAAI4F,GAAe1D,KAAKS,aAAa6C,EAAM,GAAGF,GAC1CO,EAAa3D,KAAKY,WAAW0C,EAAM,GAAGF,GACtCQ,EAAe5D,KAAKW,aAAa2C,EAAM,GAAGF,EAC9CO,KACA3D,KAAKS,aAAa6C,GAAKF,GAAOM,EAC9B1D,KAAKY,WAAW0C,GAAKF,GAAOO,EAC5B3D,KAAKW,aAAa2C,GAAKF,GAAOQ,GAKtC5D,KAAKS,aAAaoD,OAAO7D,KAAKC,MAAQ,EAAG,GACzCD,KAAKY,WAAWiD,OAAO7D,KAAKC,MAAQ,EAAG,GACvCD,KAAKW,aAAakD,OAAO7D,KAAKC,MAAQ,EAAG,GACzCD,KAAKO,QAAUP,KAAKK,UAAUG,KAC9BR,KAAKC,WAeTX,IAAK,2CACL6B,MAAO,SAAkD8B,GAIrD,IAAK,GAHDa,MAGKV,EAAMpD,KAAKE,OAAS,EAAGkD,GAAO,EAAGA,IAAO,CAI7C,IAAK,GAHDC,GAAaJ,EAAMG,GACnBW,KAEKjG,GAAI,EAAIA,EAAI,EAAGA,IAAK,CACzB,GAAIwF,GAAMD,EAAavF,CAEnBkC,MAAKgE,aAAaV,EAAKF,KACvBpD,KAAKS,aAAa6C,GAAKF,GAAOpD,KAAKwC,OAAOc,EAAKF,GAE/CW,EAAaE,KAAKX,IAG1BQ,EAAMV,GAAOW,EAEjB,MAAOD,MAQXxE,IAAK,sCACL6B,MAAO,SAA6C2C,GAUhD,IATA,GAAII,MACAC,KAGAf,EAAMpD,KAAKE,OAAS,EACpBkE,EAAeN,EAAMV,GAErBiB,EAAUrE,KAAKC,MAAQ,EAEpBmE,GAAc,CAGjB,GAAId,GAAMc,EAAaE,MACnBC,EAAavE,KAAK+B,aAAauB,EAAKF,EAIxC,IAH4B,IAAxBgB,EAAa/F,SAAc+F,EAAeN,IAAQV,KAGlDc,EAAOK,GAAX,CAEAL,EAAOK,IAAc,CAErB,IAAIC,GAAaxE,KAAKS,aAAa6C,GAAKF,GACpCqB,EAAazE,KAAKW,aAAa2C,GAAKF,EACxCpD,MAAKW,aAAa2C,GAAKF,GAAOV,OAAOC,iBAGrC,KAAK,GAAI7E,GAAIuE,KAAKW,IAAIM,EAAM,EAAG,GAAIxF,EAAIuE,KAAKqC,IAAIpB,EAAM,EAAGe,EAAU,GAAIvG,IAAK,CACxE,GAAI6G,GAAgB3E,KAAKW,aAAa7C,GAAGsF,EAAM,GAC3CwB,EAAaD,EAAgBH,CAE7BI,GAAa5E,KAAKW,aAAa2C,GAAKF,KACpCpD,KAAKW,aAAa2C,GAAKF,GAAOwB,EAC9B5E,KAAKY,WAAW0C,GAAKF,GAAOtF,GAMpC,GAAY,IAARsF,GAGAqB,IAAezE,KAAKW,aAAa2C,GAAKF,GAG1C,IAAK,GAAItF,GAAIuE,KAAKW,IAAIM,EAAM,EAAG,GAAIxF,EAAIuE,KAAKqC,IAAIpB,EAAM,EAAGe,EAAU,GAAIvG,IAAK,CACxE,GAAI+G,GAAa7E,KAAK+B,aAAajE,EAAGsF,EAAM,EACvCe,GAASU,KACVV,EAASU,IAAc,EACvBf,EAAMV,EAAM,GAAGa,KAAKnG,UAYpCwB,IAAK,qBACL6B,MAAO,SAA4B8B,GAC/BjD,KAAK8E,+BAA+B7B,EAEpC,IAAI8B,GAAiB/E,KAAKgF,yCAAyC/B,EAEnEjD,MAAKiF,oCAAoCF,MAS7CzF,IAAK,cACL6B,MAAO,SAAqB+D,GACxB,GAAIC,GAAQD,EAAQC,MAChBC,EAAaF,EAAQE,UAazB,IAZApF,KAAKG,QAAQkF,UAAU,EAAG,EAAGrF,KAAKD,OAAOE,MAAOD,KAAKD,OAAOG,QAC5DF,KAAKD,OAAOE,MAAQD,KAAKK,UAAUJ,MACnCD,KAAKD,OAAOG,OAASF,KAAKK,UAAUH,OAEhCkF,GACApF,KAAKD,OAAOuF,MAAMrF,MAAQD,KAAKK,UAAUJ,MAAQ,KACjDD,KAAKD,OAAOuF,MAAMpF,OAASF,KAAKK,UAAUH,OAAS,OAEnDF,KAAKD,OAAOuF,MAAMrF,MAAQ,UAC1BD,KAAKD,OAAOuF,MAAMpF,OAAS,WAGjB,WAAViF,GAAgC,YAAVA,GAAuBA,IAAUnF,KAAKK,UAAUkF,UAAW,CACjFvF,KAAKK,UAAYL,KAAKG,QAAQgD,gBAAgBnD,KAAKC,MAAOD,KAAKE,QAC/DF,KAAKK,UAAUkF,UAAYJ,CAE3B,KAAK,GAAI/B,GAAM,EAAGA,EAAMpD,KAAKE,OAAQkD,IACjC,IAAK,GAAIE,GAAM,EAAGA,EAAMtD,KAAKC,MAAOqD,IAAO,CACvC,GAAIE,GAAMxD,KAAK+B,aAAauB,EAAKF,EAEjC,IAAc,WAAV+B,EACA,GAAIK,GAAMxF,KAAKS,aAAa6C,GAAKF,GAC7BqC,EAAgBpD,KAAKqC,IAAI,IAAKc,EAAM,IAAM,SAC3C,CAAA,GAAc,WAAVL,EAGJ,CAAA,GAAc,SAAVA,EAAkB,CAGzB,IAAK,GAFDK,GAAMxF,KAAKY,WAAW0C,GAAKF,GAC3BsC,EAAYF,EAAMlC,EAAM,EACnBxF,EAAI,EAAGA,EAAI,EAAGA,IACnBkC,KAAKK,UAAUG,KAAKgD,EAAM1F,GAAK,CAE/B4H,IAAa,GAAKA,GAAa,IAC/B1F,KAAKK,UAAUG,KAAKgD,EAAMkC,GAAa,KAE3C1F,KAAKK,UAAUG,KAAKgD,EAAM,GAAK,GAC/B,UAGA,IAAK,GAAI1F,GAAI,EAAGA,EAAI,EAAGA,IACnBkC,KAAKK,UAAUG,KAAKgD,EAAM1F,GAAKkC,KAAKO,QAAQiD,EAAM1F,EAEtD,UAlBA,GAAI0H,GAAMxF,KAAKW,aAAa2C,GAAKF,GAC7BqC,GAAiBD,EAAM,MAASxF,KAAK8C,WAAa,KAAQ,IAoBlE,IAAK,GAAIhF,GAAI,EAAGA,EAAI,EAAGA,IACnBkC,KAAKK,UAAUG,KAAKgD,EAAM1F,GAAK2H,CAGnCzF,MAAKK,UAAUG,KAAKgD,EAAM,GAAK,KAK3CxD,KAAKG,QAAQwF,aAAa3F,KAAKK,UAAW,EAAG,MAQjDf,IAAK,cACL6B,MAAO,SAAqBgE,GACxBpE,QAAQ6E,IAAI5F,KAAK6F,SAASV,OAQ9B7F,IAAK,WACL6B,MAAO,SAAkBgE,GACrBA,EAAQA,GAAS,KACjB,IAAIW,GAAQ,EACZ,IAAc,QAAVX,EACA,IAAK,GAAI9D,GAAI,EAAGA,EAAIrB,KAAKE,OAAQmB,IAAK,CAClC,IAAK,GAAID,GAAI,EAAGA,EAAIpB,KAAKC,MAAOmB,IAAK,CACjC,GAAIoC,GAAMxD,KAAK+B,aAAaX,EAAGC,GAC3BM,EAAMjB,MAAMjB,UAAUsG,MAAM3H,KAAK4B,KAAKO,QAASiD,EAAKA,EAAM,EAC9DsC,KAAU9F,KAAKgG,SAASrE,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAAM,KAAQsE,QAAQ,GAAK,KAE3EH,GAAS,SAGb,KAAK,GAAIzE,GAAI,EAAGA,EAAIrB,KAAKE,OAAQmB,IAAK,CAClC,IAAK,GAAID,GAAI,EAAGA,EAAIpB,KAAKC,MAAOmB,IAAK,CACjC,GAAIoE,EAEU,YAAVL,EACAK,EAAMxF,KAAKS,aAAaW,GAAGC,GACV,WAAV8D,EACPK,EAAMxF,KAAKW,aAAaS,GAAGC,GACV,SAAV8D,IACPK,EAAMxF,KAAKY,WAAWQ,GAAGC,IAIzByE,GADAN,GAAe,IAARA,EACEA,EAAIS,QAAQ,GAAK,KAEjB,UAGjBH,GAAS,KAGjB,MAAOA,OAIRhG,IAGXvB,GAAOJ,QAAU2B,YAEN","file":"../SeamCarver.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RED = 0;\nvar GREEN = 1;\nvar BLUE = 2;\nvar BORDER_ENERGY = 1000;\n\n/** Seam carver removes low energy seams in an image from HTML5 canvas. */\n\nvar SeamCarver = function () {\n\n    /**\n     *\n     * Init seam carver\n     *\n     * @param {HMLT5 canvas} canvas canvas with image on it.\n     *\n     */\n    function SeamCarver(canvas) {\n        _classCallCheck(this, SeamCarver);\n\n        this.canvas = canvas;\n        this.width = canvas.width;\n        this.height = canvas.height;\n        this.context = canvas.getContext(\"2d\");\n        this.imageData = this.context.getImageData(0, 0, this.width, this.height);\n        this.picture = this.imageData.data;\n\n        // Simple implementation of energy matrix as array of arrays.\n        // Because we need to remove items, when removing the seam,\n        // maybe some sort of linked structure is more efficient.\n        this.energyMatrix = new Array(this.width);\n        this.minsumMatrix = new Array(this.width);\n        this.minxMatrix = new Array(this.width);\n        for (var i = 0; i < this.width; i++) {\n            this.energyMatrix[i] = new Float32Array(this.height);\n            this.minsumMatrix[i] = new Float32Array(this.height);\n            this.minxMatrix[i] = new Uint16Array(this.height);\n        }\n\n        console.time('createEnergyMatrix');\n\n        this.createEnergyMatrix();\n\n        console.timeEnd('createEnergyMatrix');\n    }\n\n    /**\n     * Converts pixel to index.\n     *\n     * @param {number} x The x val\n     * @param {number} y The y val\n     * @return {number} Index of 1D array\n     *\n     */\n\n\n    _createClass(SeamCarver, [{\n        key: \"pixelToIndex\",\n        value: function pixelToIndex(x, y) {\n            if (x < 0 || x >= this.width * 4 || y < 0 || y >= this.height) {\n                throw new Error('IndexOutOfBoundsException : ' + x + ',' + y);\n            }\n            // * 4 for rgba\n            return (y * this.width + x) * 4;\n        }\n    }, {\n        key: \"indexToX\",\n        value: function indexToX(index) {\n            return parseInt(index / 4 % this.width);\n        }\n    }, {\n        key: \"indexToY\",\n        value: function indexToY(index) {\n            return parseInt(index / (this.width * 4));\n        }\n    }, {\n        key: \"rgbToNum\",\n        value: function rgbToNum(red, green, blue) {\n            var rgb = red;\n            rgb = (rgb << 8) + green;\n            rgb = (rgb << 8) + blue;\n            return rgb;\n        }\n    }, {\n        key: \"numToRgb\",\n        value: function numToRgb(num) {\n            var red = num >> 16 & 0xFF;\n            var green = num >> 8 & 0xFF;\n            var blue = num & 0xFF;\n            return [red, green, blue];\n        }\n    }, {\n        key: \"isBorderPixel\",\n        value: function isBorderPixel(x, y) {\n            return x <= 0 || y <= 0 || x >= this.width - 1 || y >= this.height - 1;\n        }\n    }, {\n        key: \"pixelInRange\",\n        value: function pixelInRange(x, y) {\n            return x >= 0 && y >= 0 && x <= this.width - 1 && y <= this.height - 1;\n        }\n\n        /**\n         * Energy for single pixel.\n         *\n         * @param {number} x The x val.\n         * @param {number} y The y val.\n         * @return {number} The energy val.\n         */\n\n    }, {\n        key: \"energy\",\n        value: function energy(x, y) {\n            if (this.isBorderPixel(x, y)) {\n                return BORDER_ENERGY;\n            }\n\n            var pos_xant = this.pixelToIndex(x - 1, y);\n            var pos_xpost = this.pixelToIndex(x + 1, y);\n            var pos_yant = this.pixelToIndex(x, y - 1);\n            var pos_ypost = this.pixelToIndex(x, y + 1);\n\n            var p = this.picture; // Just to make it more readable ...\n\n            // TODO: Could include self in this calculation\n            var score = Math.sqrt((p[pos_xpost + RED] - p[pos_xant + RED]) * (p[pos_xpost + RED] - p[pos_xant + RED]) + (p[pos_xpost + GREEN] - p[pos_xant + GREEN]) * (p[pos_xpost + GREEN] - p[pos_xant + GREEN]) + (p[pos_xpost + BLUE] - p[pos_xant + BLUE]) * (p[pos_xpost + BLUE] - p[pos_xant + BLUE]) + (p[pos_ypost + RED] - p[pos_yant + RED]) * (p[pos_ypost + RED] - p[pos_yant + RED]) + (p[pos_ypost + GREEN] - p[pos_yant + GREEN]) * (p[pos_ypost + GREEN] - p[pos_yant + GREEN]) + (p[pos_ypost + BLUE] - p[pos_yant + BLUE]) * (p[pos_ypost + BLUE] - p[pos_yant + BLUE]));\n            return score;\n        }\n\n        /**\n         * Calculate energy_matrix information for pixel x,y.\n         * Assumes x and y in range.\n         */\n\n    }, {\n        key: \"recalculate\",\n        value: function recalculate(x, y) {\n            var energy_cell = {};\n\n            energy_cell.energy = this.energy(x, y);\n            energy_cell.vminsum = Number.POSITIVE_INFINITY;\n\n            // last row\n            if (y >= this.height - 1) {\n                energy_cell.vminsum = energy_cell.energy;\n                energy_cell.minx = x;\n            } else {\n                var cursum = 0;\n                var curminx = 0;\n\n                // below left\n                if (x - 1 >= 0) {\n                    energy_cell.vminsum = this.minsumMatrix[x - 1][y + 1] + energy_cell.energy;\n                    energy_cell.minx = x - 1;\n                }\n\n                // below\n                if (x < this.width) {\n                    cursum = this.minsumMatrix[x][y + 1] + energy_cell.energy;\n                    if (cursum < energy_cell.vminsum) {\n                        energy_cell.vminsum = cursum;\n                        energy_cell.minx = x;\n                    }\n                }\n\n                // below right\n                if (x + 1 < this.width) {\n                    cursum = this.minsumMatrix[x + 1][y + 1] + energy_cell.energy;\n                    if (cursum < energy_cell.vminsum) {\n                        energy_cell.vminsum = cursum;\n                        energy_cell.minx = x + 1;\n                    }\n                }\n            }\n\n            return energy_cell;\n        }\n\n        /**\n         * Iterate from bottom to top. For each pixel calculate:\n         *     * The energy for the pixel.\n         *     * From the three pixels below the current pixel, calculate the\n         *       `minx` pixel. The `minx` pixel is the pixel with the smallest\n         *       cumulative energy (defined below).\n         *     * Set the cumulative energy for this pixel as the energy of this\n         *       pixel plus the cumulative energy of th `minx` pixel.\n         *\n         * The cumulative energy of the pixels in the bottom row is simply its own\n         * energy.\n         *\n         */\n\n    }, {\n        key: \"createEnergyMatrix\",\n        value: function createEnergyMatrix() {\n            // This has to be reverse order (bottom to top)\n            this.maxVminsum = 0;\n            for (var y = this.height - 1; y >= 0; y--) {\n                // This can be in any order ...\n                for (var x = 0; x < this.width; x++) {\n                    var energy = this.recalculate(x, y);\n                    this.maxVminsum = Math.max(energy.vminsum, this.maxVminsum);\n                    this.energyMatrix[x][y] = energy.energy;\n                    this.minsumMatrix[x][y] = energy.vminsum;\n                    this.minxMatrix[x][y] = energy.minx;\n                }\n            }\n        }\n\n        /**\n         * Backtrack from smallest on first row to choosing always smallest child.\n         *\n         */\n\n    }, {\n        key: \"findVerticalSeam\",\n        value: function findVerticalSeam() {\n            var vseam = [];\n\n            var xminsum = 0;\n            var vminsum = Number.POSITIVE_INFINITY;\n\n            // Find smallest sum on first row\n            for (var x = 0; x < this.width; x++) {\n                if (this.minsumMatrix[x][0] < vminsum) {\n                    vminsum = this.minsumMatrix[x][0];\n                    xminsum = x;\n                }\n            }\n\n            vseam[0] = xminsum;\n\n            // Follow down to get array\n            var y = 0;\n            while (y < this.height - 1) {\n                xminsum = this.minxMatrix[xminsum][y];\n                y++;\n                vseam[y] = xminsum;\n            }\n\n            return vseam;\n        }\n\n        /**\n         * Remove pixels from rgb, energy and vminsum representations\n         * of image.\n         *\n         */\n\n    }, {\n        key: \"removePixelsFromDataStructures\",\n        value: function removePixelsFromDataStructures(vseam) {\n            this.imageData = this.context.createImageData(this.width - 1, this.height);\n            for (var row = this.height - 1; row >= 0; row--) {\n                var deletedCol = vseam[row];\n\n                // copy across pixels before seam col\n                for (var col = 0; col < deletedCol; col++) {\n                    var oldPos = this.pixelToIndex(col, row);\n                    var pos = oldPos - row * 4;\n                    for (var i = 0; i < 4; i++) {\n                        this.imageData.data[pos + i] = this.picture[oldPos + i];\n                    }\n                }\n\n                // Start at deleted col\n                // Can ignore last column as we will delete it\n                for (var col = deletedCol; col < this.width - 1; col++) {\n\n                    // copy across pixels after seam col\n                    var pos = this.pixelToIndex(col, row) - row * 4;\n                    var pos_right = this.pixelToIndex(col + 1, row);\n                    for (var i = 0; i < 4; i++) {\n                        this.imageData.data[pos + i] = this.picture[pos_right + i];\n                    }\n\n                    // copy across energy_matrix\n                    var energy_right = this.energyMatrix[col + 1][row];\n                    var minx_right = this.minxMatrix[col + 1][row];\n                    var minsum_right = this.minsumMatrix[col + 1][row];\n                    minx_right--;\n                    this.energyMatrix[col][row] = energy_right;\n                    this.minxMatrix[col][row] = minx_right;\n                    this.minsumMatrix[col][row] = minsum_right;\n                }\n            }\n\n            // chop off last column\n            this.energyMatrix.splice(this.width - 1, 1);\n            this.minxMatrix.splice(this.width - 1, 1);\n            this.minsumMatrix.splice(this.width - 1, 1);\n            this.picture = this.imageData.data;\n            this.width--;\n        }\n\n        /**\n         * Recalculate energy only when necessary: pixels adjacent\n         * (up, down and both sides) to the removed seam, ie the affected\n         * pixels.\n         * For any affected pixel, if the new energy is different to the previous one\n         * it's vmin sum must be recalculated therefore it is added to an array\n         * and returned by this method.\n         *\n         * @return {list} List of affected pixels for which the vminsum may be affected.\n         */\n\n    }, {\n        key: \"recalculateEnergiesAndFindAffectedPixels\",\n        value: function recalculateEnergiesAndFindAffectedPixels(vseam) {\n            var queue = [];\n\n            // bottom to top, ignore last row\n            for (var row = this.height - 2; row >= 0; row--) {\n                var deletedCol = vseam[row];\n                var affectedCols = [];\n\n                for (var i = -1; i < 1; i++) {\n                    var col = deletedCol + i;\n\n                    if (this.pixelInRange(col, row)) {\n                        this.energyMatrix[col][row] = this.energy(col, row);\n                        // enqueue pixel in range\n                        affectedCols.push(col);\n                    }\n                }\n                queue[row] = affectedCols;\n            }\n            return queue;\n        }\n\n        /**\n         * Recalculate vminsum for affected pixels\n         */\n\n    }, {\n        key: \"recalculateVminsumForAffectedPixels\",\n        value: function recalculateVminsumForAffectedPixels(queue) {\n            var marked = {};\n            var enqueued = {};\n            var maxRow = -1;\n            // start at second to last row\n            var row = this.height - 2;\n            var enqueuedCols = queue[row];\n            // used later in loop so as not to go past borders\n            var lastCol = this.width - 1;\n\n            while (enqueuedCols) {\n\n                // This iterates in topological order (bottom to top)\n                var col = enqueuedCols.pop();\n                var pixelIndex = this.pixelToIndex(col, row);\n                if (enqueuedCols.length === 0) enqueuedCols = queue[--row];\n\n                // already explored this pixel\n                if (marked[pixelIndex]) continue;\n\n                marked[pixelIndex] = true;\n\n                var nodeEnergy = this.energyMatrix[col][row];\n                var oldVminsum = this.minsumMatrix[col][row];\n                this.minsumMatrix[col][row] = Number.POSITIVE_INFINITY;\n\n                // check three parents in row below\n                for (var i = Math.max(col - 1, 0); i < Math.min(col + 2, lastCol + 1); i++) {\n                    var parentVminsum = this.minsumMatrix[i][row + 1];\n                    var newVminsum = parentVminsum + nodeEnergy;\n\n                    if (newVminsum < this.minsumMatrix[col][row]) {\n                        this.minsumMatrix[col][row] = newVminsum;\n                        this.minxMatrix[col][row] = i;\n                    }\n                }\n\n                // If we are on first row, no potentially affected children in row\n                // above so skip next step.\n                if (row === 0) continue;\n\n                // Only enqueue the children if the vminsum has changed\n                if (oldVminsum === this.minsumMatrix[col][row]) continue;\n\n                // enqueue three affected children from row above\n                for (var i = Math.max(col - 1, 0); i < Math.min(col + 2, lastCol + 1); i++) {\n                    var childIndex = this.pixelToIndex(i, row - 1);\n                    if (!enqueued[childIndex]) {\n                        enqueued[childIndex] = true;\n                        queue[row - 1].push(i);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Removes vertical seam.\n         * Recalculates pixels depending on removed pixel.\n         */\n\n    }, {\n        key: \"removeVerticalSeam\",\n        value: function removeVerticalSeam(vseam) {\n            this.removePixelsFromDataStructures(vseam);\n\n            var affectedPixels = this.recalculateEnergiesAndFindAffectedPixels(vseam);\n\n            this.recalculateVminsumForAffectedPixels(affectedPixels);\n        }\n\n        /*\n         * Takes field as arg to print matrix, default is rgb, accepts energy.\n         *\n         */\n\n    }, {\n        key: \"reDrawImage\",\n        value: function reDrawImage(options) {\n            var field = options.field;\n            var actualSize = options.actualSize;\n            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.canvas.width = this.imageData.width;\n            this.canvas.height = this.imageData.height;\n\n            if (actualSize) {\n                this.canvas.style.width = this.imageData.width + 'px';\n                this.canvas.style.height = this.imageData.height + 'px';\n            } else {\n                this.canvas.style.width = 'inherit';\n                this.canvas.style.height = 'inherit';\n            }\n\n            if (field === 'energy' || field === 'vminsum' || field !== this.imageData.dataField) {\n                this.imageData = this.context.createImageData(this.width, this.height);\n                this.imageData.dataField = field;\n\n                for (var row = 0; row < this.height; row++) {\n                    for (var col = 0; col < this.width; col++) {\n                        var pos = this.pixelToIndex(col, row);\n\n                        if (field === 'energy') {\n                            var val = this.energyMatrix[col][row];\n                            var normalizedVal = Math.min(255, val / 255 * 255);\n                        } else if (field === 'minsum') {\n                            var val = this.minsumMatrix[col][row];\n                            var normalizedVal = (val - 1000) / (this.maxVminsum - 1000) * 255;\n                        } else if (field === 'minx') {\n                            var val = this.minxMatrix[col][row];\n                            var direction = val - col + 1;\n                            for (var i = 0; i < 3; i++) {\n                                this.imageData.data[pos + i] = 0;\n                            }\n                            if (direction >= 0 && direction <= 2) {\n                                this.imageData.data[pos + direction] = 255;\n                            }\n                            this.imageData.data[pos + 3] = 255;\n                            continue;\n                        } else {\n                            // rgb\n                            for (var i = 0; i < 4; i++) {\n                                this.imageData.data[pos + i] = this.picture[pos + i];\n                            }\n                            continue;\n                        }\n\n                        for (var i = 0; i < 3; i++) {\n                            this.imageData.data[pos + i] = normalizedVal;\n                        }\n                        // make opaque\n                        this.imageData.data[pos + 3] = 255;\n                    }\n                }\n            }\n\n            this.context.putImageData(this.imageData, 0, 0);\n        }\n\n        /**\n         * Prints one of the values of the energy_matrix. Useful for debugging.\n         */\n\n    }, {\n        key: \"printMatrix\",\n        value: function printMatrix(field) {\n            console.log(this.toString(field));\n        }\n\n        /**\n         * Returns string of internal matrix\n         */\n\n    }, {\n        key: \"toString\",\n        value: function toString(field) {\n            field = field || 'rgb';\n            var lines = '';\n            if (field === 'rgb') {\n                for (var y = 0; y < this.height; y++) {\n                    for (var x = 0; x < this.width; x++) {\n                        var pos = this.pixelToIndex(x, y);\n                        var rgb = Array.prototype.slice.call(this.picture, pos, pos + 3);\n                        lines += (this.rgbToNum(rgb[0], rgb[1], rgb[2]) / 100000).toFixed(2) + '\\t';\n                    }\n                    lines += '\\n';\n                }\n            } else {\n                for (var y = 0; y < this.height; y++) {\n                    for (var x = 0; x < this.width; x++) {\n                        var val;\n\n                        if (field === 'energy') {\n                            val = this.energyMatrix[x][y];\n                        } else if (field === 'minsum') {\n                            val = this.minsumMatrix[x][y];\n                        } else if (field === 'minx') {\n                            val = this.minxMatrix[x][y];\n                        }\n\n                        if (val || val === 0) {\n                            lines += val.toFixed(2) + \"\\t\";\n                        } else {\n                            lines += '-----\\t';\n                        }\n                    }\n                    lines += '\\n';\n                }\n            }\n            return lines;\n        }\n    }]);\n\n    return SeamCarver;\n}();\n\nmodule.exports = SeamCarver;\n\n},{}]},{},[1]);\n"]}